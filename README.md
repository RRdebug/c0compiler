# 前言

IMU的编译原理大作业，写一个c0的编译器，其实解释器也写了的，但本项目生成的只是假象的栈式指令，解释器意义不大。重要的还是提供一个写编译器的思路。本项目完整的实现了一个前后端分离的编译器

**ps:** 符号表那边的实现很蠢，完全按自己感觉来的，~~因为没听课~~，日后可能重构下。

流程为 ：<u>**词法分析 -> 语法分析 -> 语义分析 -> 代码优化 -> 目标代码生成**</u>

[词法分析](#词法分析器)的任务是输入程序源代码输出Token序列



![流程图](https://github.com/RRdebug/c0compiler/blob/main/image/c0.png)

# 文法规则

学校给的是BNF，我把他转为了等价的上下文无关文法



1. `P -> OVD OFD MF` (程序 -> 可选变量定义部分 可选自定义函数定义部分 主函数)
2. `OVD -> VD | ε` (可选变量定义部分 -> 变量定义部分 | 空)
3. `OFD -> FD OFD | ε` (可选自定义函数定义部分 -> 函数定义 可选自定义函数定义部分 | 空)
4. `VD -> 'int' id SD` (变量定义部分 -> 'int' 标识符 后续变量定义)
5. `SD -> ',' id SD | ';'` (后续变量定义 -> ',' 标识符 后续变量定义 | ';')
6. `FD -> ('int' id | 'void' id) '(' ')' SP` (函数定义 -> ('int' 标识符 | 'void' 标识符) '()' 分程序)
7. `MF -> 'void main' '(' ')' SP` (主函数 -> 'void main' '()' 分程序)
8. `SP -> '{' OVD SS '}'` (分程序 -> '{' 可选变量定义部分 语句序列 '}')
9. `SS -> S MS` (语句序列 -> 语句 更多语句)
10. `MS -> S MS | ε` (更多语句 -> 语句 更多语句 | 空)
11. `S -> CS | LS | '{' SS '}' | FCS | AS | RET | RS | WS | ';'` (语句 -> 条件语句 | 循环语句 | '{' 语句序列 '}' | 自定义函数调用语句 | 赋值语句 | 返回语句 | 读语句 | 写语句 | ';')
12. `CS -> 'if' '(' E ')' S OES` (条件语句 -> 'if' '(' 表达式 ')' 语句 可选else语句)
13. `OES -> 'else' S | ε` (可选else语句 -> 'else' 语句 | 空)
14. `LS -> 'while' '(' E ')' S` (循环语句 -> 'while' '(' 表达式 ')' 语句)
15. `FCS -> FC ';'` (自定义函数调用语句 -> 自定义函数调用 ';')
16. `AS -> id '=' E ';'` (赋值语句 -> 标识符 '=' 表达式 ';')
17. `RET -> 'return' OE ';'` (返回语句 -> 'return' 可选表达式 ';')
18. `OE -> '(' E ')' | ε` (可选表达式 -> '(' 表达式 ')' | 空)
19. `RS -> 'scanf' '(' id ')' ';'` (读语句 -> 'scanf' '(' 标识符 ')' ';')
20. `WS -> 'printf' '(' OE ')' ';'` (写语句 -> 'printf' '(' 可选表达式 ')' ';')
21. `E -> OP T SE` (表达式 -> 可选前缀 项 后续表达式)
22. `OP -> '+' | '-' | ε` (可选前缀 -> '+' | '-' | 空)
23. `SE -> ('+' | '-') T SE | ε` (后续表达式 -> ('+' | '-') 项 后续表达式 | 空)
24. `T -> F ST` (项 -> 因子 后续项)
25. `ST -> ('*' | '/') F ST | ε` (后续项 -> ('*' | '/') 因子 后续项 | 空)
26. `F -> id | '(' E ')' | 'num' | FC` (因子 -> 标识符 | '(' 表达式 ')' | 数字 | 自定义函数调用)
27. `FC -> id '(' ')'` (自定义函数调用 -> 标识符 '()')



# 假象的栈式指令



| 指令  | 参数  | 描述                                               |
| ----- | ----- | -------------------------------------------------- |
| `LIT` | `0 a` | 将常数值取到栈顶，a为常数值                        |
| `LOD` | `t a` | 将变量值取到栈顶，a为相对地址，t为层数             |
| `STO` | `t a` | 将栈顶内容送入某变量单元中，a为相对地址，t为层数   |
| `CAL` | `0 a` | 调用函数，a为函数地址                              |
| `INT` | `0 a` | 在运行栈中为被调用的过程开辟a个单元的数据区        |
| `JMP` | `0 a` | 无条件跳转至a地址                                  |
| `JPC` | `0 a` | 条件跳转，当栈顶值为0，则跳转至a地址，否则顺序执行 |
| `ADD` | `0 0` | 次栈顶与栈顶相加，退两个栈元素，结果值进栈         |
| `SUB` | `0 0` | 次栈顶减去栈顶，退两个栈元素，结果值进栈           |
| `MUL` | `0 0` | 次栈顶乘以栈顶，退两个栈元素，结果值进栈           |
| `DIV` | `0 0` | 次栈顶除以栈顶，退两个栈元素，结果值进栈           |
| `RED` | `0 0` | 从命令行读入一个输入置于栈顶                       |
| `WRT` | `0 0` | 栈顶值输出至屏幕并换行                             |
| `RET` | `0 0` | 函数调用结束后,返回调用点并退栈                    |



# 词法分析器

词法分析是程序源代码的第一个阶段，用于将源代码分解为基本的词法单元或词法符号。词法单元是编程语言中的最小语法单元，通常是标识符、关键字、运算符、常量和分隔符等。

词法分析一般是基于有穷状态机（**DFA**）来进行自动的分析的

开始是状态机的起始态

![DFA](https://github.com/RRdebug/c0compiler/blob/main/image/DFA.png)
